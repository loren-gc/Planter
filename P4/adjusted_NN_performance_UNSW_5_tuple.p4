########################################################################
# THIS FILE IS PART OF Planter PROJECT
# Copyright (c) Changgang Zheng and Computing Infrastructure Group
# Department of Engineering Science, University of Oxford
# All rights reserved.
# E-mail: changgang.zheng@eng.ox.ac.uk or changgangzheng@qq.com
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at :
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#########################################################################
# This file was autogenerated

/*
 * Planter
 *
 * This program implements a simple protocol. It can be carried over Ethernet
 * (Ethertype 0x1234).
 *
 * The Protocol header looks like this:
 *
 *        0                1                  2               3
 * +----------------+----------------+----------------+---------------+
 * |      P         |       4        |     Version    |     Type      |
 * +----------------+----------------+----------------+---------------+
 * |                              feature0                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature1                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature2                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature3                            |
 * +----------------+----------------+----------------+---------------+
 * |                              Result                              |
 * +----------------+----------------+----------------+---------------+
 *
 * P is an ASCII Letter 'P' (0x50)
 * 4 is an ASCII Letter '4' (0x34)
 * Version is currently 1 (0x01)
 * Type is currently 1 (0x01)
 *
 * The device receives a packet, do the classification, fills in the
 * result and sends the packet back out of the same port it came in on, while
 * swapping the source and destination addresses.
 *
 * If an unknown operation is specified or the header is not valid, the packet
 * is dropped
 */

#include <core.p4>
#include <tna.p4>

/*************************************************************************
*********************** headers and metadata******************************
*************************************************************************/

const bit<16> ETHERTYPE_Planter = 0x1234;
const bit<8>  Planter_P     = 0x50;   // 'P'
const bit<8>  Planter_4     = 0x34;   // '4'
const bit<8>  Planter_VER   = 0x01;   // v0.1

header ethernet_h {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header Planter_h{
    bit<8> p;
    bit<8> four;
    bit<8> ver;
    bit<8> typ;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> result;
}

struct header_t {
    ethernet_h   ethernet;
    Planter_h    Planter;
}

struct metadata_t {
    bit<10> middle_c0;
    bit<10> middle_c1;
    bit<10> compare0_1;
    bit<64> bnnInput;
    bit<64> XNOROutput;
    bit<64> NextLayerInput;
    bit<1> activated;
    bit<32>  DstAddr;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> result;
    bit<8> flag ;
}

typedef bit<64> weights_data_t;

register<weights_data_t> weights(1024);

/*************************************************************************
*********************** Ingress Parser ***********************************
*************************************************************************/

parser SwitchIngressParser(
    packet_in pkt,
    out header_t hdr,
    out metadata_t meta,
    out ingress_intrinsic_metadata_t ig_intr_md) {

    state start {
        pkt.extract(ig_intr_md);
        pkt.advance(PORT_METADATA_SIZE);
        transition parse_ethernet;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
        ETHERTYPE_Planter : check_planter_version;
        default           : accept;
        }
    }

    state check_planter_version {
        transition select(pkt.lookahead<Planter_h>().p,
                          pkt.lookahead<Planter_h>().four,
                          pkt.lookahead<Planter_h>().ver) {
        (Planter_P, Planter_4, Planter_VER) : parse_planter;
        default                             : accept;
        }
    }

    state parse_planter {
        pkt.extract(hdr.Planter);
        meta.feature0 = hdr.Planter.feature0;
        meta.feature1 = hdr.Planter.feature1;
        meta.feature2 = hdr.Planter.feature2;
        meta.feature3 = hdr.Planter.feature3;
        meta.flag = 1 ;
        transition accept;
    }
}

/*************************************************************************
*********************** Ingress Deparser *********************************
**************************************************************************/

control SwitchIngressDeparser(
    packet_out pkt,
    inout header_t hdr,
    in metadata_t ig_md,
    in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
*********************** Egress Parser ***********************************
*************************************************************************/

parser SwitchEgressParser(
    packet_in pkt,
    out header_t hdr,
    out metadata_t meta,
    out egress_intrinsic_metadata_t eg_intr_md) {
    state start {
        pkt.extract(eg_intr_md);
        transition accept;
        }

}

/*************************************************************************
*********************** Egress Deparser *********************************
**************************************************************************/

control SwitchEgressDeparser(
    packet_out pkt,
    inout header_t hdr,
    in metadata_t eg_md,
    in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
*********************** Ingress Processing********************************
**************************************************************************/

control SwitchIngress(
    inout header_t hdr,
    inout metadata_t meta,
    in ingress_intrinsic_metadata_t ig_intr_md,
    in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
    inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
    inout ingress_intrinsic_metadata_for_tm_t ig_tm_md
    inout register<bit<64>> weights) {

    action drop() {
        ig_dprsr_md.drop_ctl = 0x1;
    }

    action send(PortId_t port) {
        ig_tm_md.ucast_egress_port = port;
    }

    bit<128> m1 = 0x55555555555555555555555555555555;
    bit<128> m2 = 0x33333333333333333333333333333333;
    bit<128> m4 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;
    bit<128> m8 = 0x00ff00ff00ff00ff00ff00ff00ff00ff;
    bit<128> m16= 0x0000ffff0000ffff0000ffff0000ffff;
    bit<128> m32= 0x00000000ffffffff00000000ffffffff;
    bit<128> m64= 0x0000000000000000ffffffffffffffff;

    action XNOR(bit<64> weight){
        meta.XNOROutput = weight^meta.bnnInput;
        meta.XNOROutput = ~meta.XNOROutput;
    }

    action BitCount_l0(bit<64> bitInput){
        bit<128> x= (bit<128>)bitInput;
        x = (x & m1 ) + ((x >>  1) & m1 );
        x = (x & m2 ) + ((x >>  2) & m2 );
        x = (x & m4 ) + ((x >>  4) & m4 );
        x = (x & m8 ) + ((x >>  8) & m8 );
        x = (x & m16) + ((x >> 16) & m16);
        x = (x & m32) + ((x >> 32) & m32);
        x = (x & m64) + ((x >> 64) & m64);
        meta.activated = (x>22) ? (bit<1>)1 : 0;
        meta.NextLayerInput = meta.NextLayerInput<<1;
        meta.NextLayerInput = meta.NextLayerInput + (bit<64>)meta.activated;
    }

    action BitCount_l1(bit<64> bitInput){
        bit<128> x= (bit<128>)bitInput;
        x = (x & m1 ) + ((x >>  1) & m1 );
        x = (x & m2 ) + ((x >>  2) & m2 );
        x = (x & m4 ) + ((x >>  4) & m4 );
        x = (x & m8 ) + ((x >>  8) & m8 );
        x = (x & m16) + ((x >> 16) & m16);
        x = (x & m32) + ((x >> 32) & m32);
        x = (x & m64) + ((x >> 64) & m64);
        meta.activated = (x>28) ? (bit<1>)1 : 0;
        meta.NextLayerInput = meta.NextLayerInput<<1;
        meta.NextLayerInput = meta.NextLayerInput + (bit<64>)meta.activated;
    }

    action BitCount_c0(bit<64> bitInput){
        bit<128> x= (bit<128>)bitInput;
        x = (x & m1 ) + ((x >>  1) & m1 );
        x = (x & m2 ) + ((x >>  2) & m2 );
        x = (x & m4 ) + ((x >>  4) & m4 );
        x = (x & m8 ) + ((x >>  8) & m8 );
        x = (x & m16) + ((x >> 16) & m16);
        x = (x & m32) + ((x >> 32) & m32);
        x = (x & m64) + ((x >> 64) & m64);
        meta.middle_c0 = (bit<10>) x;
    }

    action BitCount_c1(bit<64> bitInput){
        bit<128> x= (bit<128>)bitInput;
        x = (x & m1 ) + ((x >>  1) & m1 );
        x = (x & m2 ) + ((x >>  2) & m2 );
        x = (x & m4 ) + ((x >>  4) & m4 );
        x = (x & m8 ) + ((x >>  8) & m8 );
        x = (x & m16) + ((x >> 16) & m16);
        x = (x & m32) + ((x >> 32) & m32);
        x = (x & m64) + ((x >> 64) & m64);
        meta.middle_c1 = (bit<10>) x;
    }

    action Layer0_Process(bit <10> offset){ 
        bit <64> weight = 0;
        weights.read( weight, (bit<32>)offset+0);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+1);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+2);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+3);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+4);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+5);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+6);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+7);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+8);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+9);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+10);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+11);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+12);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+13);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+14);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+15);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+16);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+17);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+18);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+19);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+20);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+21);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+22);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+23);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+24);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+25);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+26);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+27);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+28);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+29);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+30);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+31);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+32);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+33);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+34);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+35);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+36);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+37);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+38);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+39);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+40);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+41);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+42);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+43);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+44);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+45);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+46);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+47);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+48);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+49);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+50);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+51);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+52);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+53);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+54);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+55);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[44:0];
        BitCount_l0(meta.XNOROutput);
    }

    action Layer1_Process(bit <10> offset){ 
        bit <64> weight = 0;
        meta.NextLayerInput = 0;
        weights.read(weight, (bit<32>)offset+0);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+1);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+2);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+3);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+4);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+5);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+6);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+7);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+8);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+9);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+10);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+11);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+12);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+13);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+14);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+15);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+16);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+17);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+18);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+19);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+20);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+21);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+22);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+23);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+24);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+25);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+26);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+27);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+28);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+29);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+30);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+31);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+32);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+33);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+34);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+35);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+36);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+37);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+38);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+39);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+40);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+41);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+42);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+43);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+44);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+45);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+46);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+47);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+48);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+49);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+50);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+51);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+52);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+53);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+54);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
        weights.read(weight, (bit<32>)offset+55);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_l1(meta.XNOROutput);
    }

    action Layer2_Process(bit <10> offset){ 
        bit <64> weight = 0;
        weights.read( weight, (bit<32>)offset+0);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_c0(meta.XNOROutput);
        weights.read( weight, (bit<32>)offset+1);
        XNOR(weight);
        meta.XNOROutput = (bit<64>)meta.XNOROutput[55:0];
        BitCount_c1(meta.XNOROutput);
    }

    action compare(){
        meta.compare0_1 = meta.middle_c0 - meta.middle_c1;
    }

    action BuildInput(){
        meta.bnnInput = (meta.bnnInput + (bit <64>) meta.feature0) << 16;
        meta.bnnInput = (meta.bnnInput + (bit <64>) meta.feature1) << 5;
        meta.bnnInput = (meta.bnnInput + (bit <64>) meta.feature2) << 8;
        meta.bnnInput = (meta.bnnInput + (bit <64>) meta.feature3) ;
    }

    apply{
        meta.bnnInput = 0;
        meta.XNOROutput = 0;
        meta.NextLayerInput = 0;
        BuildInput();

        Layer0_Process(0);
        meta.bnnInput = meta.NextLayerInput;
        meta.NextLayerInput = 0;

        Layer1_Process(56);
        meta.bnnInput = meta.NextLayerInput;
        meta.NextLayerInput = 0;

        Layer2_Process(112);

        compare();
        if(meta.compare0_1& 0b1000000000!=0){
             meta.result = 1;
         }
        else{
             meta.result = 0;
         }
        send(ig_intr_md.ingress_port);
    }
}
/*************************************************************************
*********************** egress Processing********************************
**************************************************************************/

control SwitchEgress(inout header_t hdr,
    inout metadata_t meta,
    in egress_intrinsic_metadata_t eg_intr_md,
    in egress_intrinsic_metadata_from_parser_t eg_prsr_md,
    inout egress_intrinsic_metadata_for_deparser_t     eg_dprsr_md,
    inout egress_intrinsic_metadata_for_output_port_t  eg_oport_md) {

    action drop() {
        eg_dprsr_md.drop_ctl = 0x1;
    }

    apply {
    }
}
/*************************************************************************
***********************  S W I T C H  ************************************
*************************************************************************/

Pipeline(SwitchIngressParser(),
    SwitchIngress(weights),
    SwitchIngressDeparser(),
    SwitchEgressParser(),
    SwitchEgress(),
    SwitchEgressDeparser()) pipe;

Switch(pipe) main;
